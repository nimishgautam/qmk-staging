#!/usr/bin/env python3

"""
Reads in corne layout line-by-line
Reverses the order of right-hand keyboard elements only
"""

def main():
    input_file = "ng_layout_corne.c"
    output_file = "ng_layout_corne_reversed.c"

    with open(input_file, "r") as f:
        lines = f.readlines()

    line_iter = iter(lines)
    state = 'copy_lines'
    print('// This file is generated by reverse_corne_layout.py')
    print("// Do not edit this file directly, it'll make things messy later")
    for line in line_iter:
        if state == 'copy_lines':
            if "LAYOUT_split_3x6_3(" in line:
                # replace LAYOUT_split_3x6_3 with LAYOUT
                # because the w_corne assumes it's a single file, and not really split
                print(line.replace("LAYOUT_split_3x6_3(", "LAYOUT("), end='')
                state = 'reverse_lines'
                line = next(line_iter)
            else:
                # has a newline in it already
                print(line, end='')
        if state == 'reverse_lines':
            layout_lines = [line]
            still_in_layout = True
            while still_in_layout:
                next_line = next(line_iter)
                next_line = next_line.strip()
                if next_line.startswith('),'):
                    still_in_layout = False
                    process_layout(layout_lines)
                    # we just stripped the newline, put it back
                    print(next_line)
                    state = 'copy_lines'
                else:
                    layout_lines.append(next_line)
            
def process_layout(layout_lines):
    current_row = 0
    for line in layout_lines:
        line = line.strip()
        if line.startswith('//') or line.startswith('/*') or line.startswith('*'):
            print(line) # just print any comment lines as-is
        else: # else not a comment, a real layout line
            current_row += 1
            row_elements = get_row_elements(line)
            row_size = len(row_elements)
            # sometimes comment lines get read as rows, no need to output
            if row_size == 0:
                continue
            row_half = row_size // 2
            row_elements = row_elements[:row_half] + row_elements[row_half:][::-1]
            # this is the middle element, adding some spaces for readability
            row_elements[row_half-1] += " " * 15
            is_thumb_line = False
            if len(row_elements) == 6:
                is_thumb_line = True
            row = (',').join(row_elements)
            if not is_thumb_line:
                row += ','
            print(row)

def get_row_elements(line):
    base_tokens = line.split(',')
    candidates = iter(base_tokens)
    # need to handle nested parens
    # if we find unbalanced parens, gobble up next token and append until we balance
    elements = []
    for candidate in candidates:
        term = candidate.strip()
        bal = term.count('(') - term.count(')')
        while bal > 0:
            next_term = next(candidates)
            term += (", " + next_term.strip())
            bal = term.count('(') - term.count(')')
        # check if blank, only add if it's not blank
        if len(term) > 0:
            # need to pad with spaces to get to 15 characters
            term += " " * (15 - len(term))
            elements.append(term)
    return elements

if __name__ == "__main__":
    main()